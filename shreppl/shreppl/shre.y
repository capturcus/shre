/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.3). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the shre_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE shre__scan_string(const char *str, yyscan_t scanner);
extern void shre__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void shre_lex_destroy(yyscan_t scanner);
extern char* shre_get_text(yyscan_t scanner);

extern yyscan_t shre__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Program* program_;
  Function* function_;
  ArgList* arglist_;
  LetIns* letins_;
  OptionalHash* optionalhash_;
  LetIn* letin_;
  Expr* expr_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, shre_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _HASH      /* # */
%token          _RARROW    /* -> */
%token          _COLON     /* : */
%token          _EQ        /* = */
%token<_string> _STRING_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <program_> Program
%type <function_> Function
%type <arglist_> ArgList
%type <letins_> LetIns
%type <optionalhash_> OptionalHash
%type <letin_> LetIn
%type <expr_> Expr

%start Program

%%

Program : Function { $$ = new ProgramFunction($1); result->program_ = $$; }
  | Function Program { $$ = new Program1($1, $2); result->program_ = $$; }
;
Function : _IDENT_ ArgList _RARROW _IDENT_ _COLON LetIns { $$ = new Function1($1, $2, $4, $6); result->function_ = $$; }
;
ArgList : _IDENT_ { $$ = new ArgListIdent($1); result->arglist_ = $$; }
  | _IDENT_ ArgList { $$ = new ArgList1($1, $2); result->arglist_ = $$; }
;
LetIns : LetIn OptionalHash { $$ = new LetIns1($1, $2); result->letins_ = $$; }
  | LetIn OptionalHash LetIns { $$ = new LetIns2($1, $2, $3); result->letins_ = $$; }
;
OptionalHash : /* empty */ { $$ = new OptionalHash1(); result->optionalhash_ = $$; }
  | _HASH { $$ = new OptionalHash2(); result->optionalhash_ = $$; }
;
LetIn : _IDENT_ _EQ Expr { $$ = new LetIn1($1, $3); result->letin_ = $$; }
  | Expr { $$ = new LetInExpr($1); result->letin_ = $$; }
;
Expr : _IDENT_ { $$ = new ExprIdent($1); result->expr_ = $$; }
  | _INTEGER_ { $$ = new ExprInteger($1); result->expr_ = $$; }
  | _DOUBLE_ { $$ = new ExprDouble($1); result->expr_ = $$; }
  | _STRING_ { $$ = new ExprString($1); result->expr_ = $$; }
;

%%


/* Entrypoint: parse Program* from file. */
Program* pProgram(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Program* from string. */
Program* psProgram(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = shre__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  shre__delete_buffer(buf, scanner);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Function* from file. */
Function* pFunction(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.function_;
  }
}

/* Entrypoint: parse Function* from string. */
Function* psFunction(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = shre__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  shre__delete_buffer(buf, scanner);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.function_;
  }
}

/* Entrypoint: parse ArgList* from file. */
ArgList* pArgList(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arglist_;
  }
}

/* Entrypoint: parse ArgList* from string. */
ArgList* psArgList(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = shre__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  shre__delete_buffer(buf, scanner);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arglist_;
  }
}

/* Entrypoint: parse LetIns* from file. */
LetIns* pLetIns(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.letins_;
  }
}

/* Entrypoint: parse LetIns* from string. */
LetIns* psLetIns(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = shre__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  shre__delete_buffer(buf, scanner);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.letins_;
  }
}

/* Entrypoint: parse OptionalHash* from file. */
OptionalHash* pOptionalHash(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optionalhash_;
  }
}

/* Entrypoint: parse OptionalHash* from string. */
OptionalHash* psOptionalHash(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = shre__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  shre__delete_buffer(buf, scanner);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.optionalhash_;
  }
}

/* Entrypoint: parse LetIn* from file. */
LetIn* pLetIn(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.letin_;
  }
}

/* Entrypoint: parse LetIn* from string. */
LetIn* psLetIn(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = shre__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  shre__delete_buffer(buf, scanner);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.letin_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = shre__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = shre__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  shre__delete_buffer(buf, scanner);
  shre_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}



