/* File generated by the BNF Converter (bnfc 2.9.3). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class Function;
class ArgList;
class LetIns;
class OptionalHash;
class LetIn;
class Expr;
class ProgramFunction;
class Program1;
class Function1;
class ArgListIdent;
class ArgList1;
class LetIns1;
class LetIns2;
class OptionalHash1;
class OptionalHash2;
class LetIn1;
class LetInExpr;
class ExprIdent;
class ExprInteger;
class ExprDouble;
class ExprString;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitFunction(Function *p) = 0;
  virtual void visitArgList(ArgList *p) = 0;
  virtual void visitLetIns(LetIns *p) = 0;
  virtual void visitOptionalHash(OptionalHash *p) = 0;
  virtual void visitLetIn(LetIn *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitProgramFunction(ProgramFunction *p) = 0;
  virtual void visitProgram1(Program1 *p) = 0;
  virtual void visitFunction1(Function1 *p) = 0;
  virtual void visitArgListIdent(ArgListIdent *p) = 0;
  virtual void visitArgList1(ArgList1 *p) = 0;
  virtual void visitLetIns1(LetIns1 *p) = 0;
  virtual void visitLetIns2(LetIns2 *p) = 0;
  virtual void visitOptionalHash1(OptionalHash1 *p) = 0;
  virtual void visitOptionalHash2(OptionalHash2 *p) = 0;
  virtual void visitLetIn1(LetIn1 *p) = 0;
  virtual void visitLetInExpr(LetInExpr *p) = 0;
  virtual void visitExprIdent(ExprIdent *p) = 0;
  virtual void visitExprInteger(ExprInteger *p) = 0;
  virtual void visitExprDouble(ExprDouble *p) = 0;
  virtual void visitExprString(ExprString *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;

};

class Function : public Visitable
{
public:
  virtual Function *clone() const = 0;

};

class ArgList : public Visitable
{
public:
  virtual ArgList *clone() const = 0;

};

class LetIns : public Visitable
{
public:
  virtual LetIns *clone() const = 0;

};

class OptionalHash : public Visitable
{
public:
  virtual OptionalHash *clone() const = 0;

};

class LetIn : public Visitable
{
public:
  virtual LetIn *clone() const = 0;

};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;

};



class ProgramFunction : public Program
{
public:
  Function *function_;

  ProgramFunction(const ProgramFunction &);
  ProgramFunction &operator=(const ProgramFunction &);
  ProgramFunction(Function *p1);
  ~ProgramFunction();
  virtual void accept(Visitor *v);
  virtual ProgramFunction *clone() const;
  void swap(ProgramFunction &);
};

class Program1 : public Program
{
public:
  Function *function_;
  Program *program_;

  Program1(const Program1 &);
  Program1 &operator=(const Program1 &);
  Program1(Function *p1, Program *p2);
  ~Program1();
  virtual void accept(Visitor *v);
  virtual Program1 *clone() const;
  void swap(Program1 &);
};

class Function1 : public Function
{
public:
  Ident ident_1;
  ArgList *arglist_;
  Ident ident_2;
  LetIns *letins_;

  Function1(const Function1 &);
  Function1 &operator=(const Function1 &);
  Function1(Ident p1, ArgList *p2, Ident p3, LetIns *p4);
  ~Function1();
  virtual void accept(Visitor *v);
  virtual Function1 *clone() const;
  void swap(Function1 &);
};

class ArgListIdent : public ArgList
{
public:
  Ident ident_;

  ArgListIdent(const ArgListIdent &);
  ArgListIdent &operator=(const ArgListIdent &);
  ArgListIdent(Ident p1);
  ~ArgListIdent();
  virtual void accept(Visitor *v);
  virtual ArgListIdent *clone() const;
  void swap(ArgListIdent &);
};

class ArgList1 : public ArgList
{
public:
  Ident ident_;
  ArgList *arglist_;

  ArgList1(const ArgList1 &);
  ArgList1 &operator=(const ArgList1 &);
  ArgList1(Ident p1, ArgList *p2);
  ~ArgList1();
  virtual void accept(Visitor *v);
  virtual ArgList1 *clone() const;
  void swap(ArgList1 &);
};

class LetIns1 : public LetIns
{
public:
  LetIn *letin_;
  OptionalHash *optionalhash_;

  LetIns1(const LetIns1 &);
  LetIns1 &operator=(const LetIns1 &);
  LetIns1(LetIn *p1, OptionalHash *p2);
  ~LetIns1();
  virtual void accept(Visitor *v);
  virtual LetIns1 *clone() const;
  void swap(LetIns1 &);
};

class LetIns2 : public LetIns
{
public:
  LetIn *letin_;
  OptionalHash *optionalhash_;
  LetIns *letins_;

  LetIns2(const LetIns2 &);
  LetIns2 &operator=(const LetIns2 &);
  LetIns2(LetIn *p1, OptionalHash *p2, LetIns *p3);
  ~LetIns2();
  virtual void accept(Visitor *v);
  virtual LetIns2 *clone() const;
  void swap(LetIns2 &);
};

class OptionalHash1 : public OptionalHash
{
public:

  OptionalHash1(const OptionalHash1 &);
  OptionalHash1 &operator=(const OptionalHash1 &);
  OptionalHash1();
  ~OptionalHash1();
  virtual void accept(Visitor *v);
  virtual OptionalHash1 *clone() const;
  void swap(OptionalHash1 &);
};

class OptionalHash2 : public OptionalHash
{
public:

  OptionalHash2(const OptionalHash2 &);
  OptionalHash2 &operator=(const OptionalHash2 &);
  OptionalHash2();
  ~OptionalHash2();
  virtual void accept(Visitor *v);
  virtual OptionalHash2 *clone() const;
  void swap(OptionalHash2 &);
};

class LetIn1 : public LetIn
{
public:
  Ident ident_;
  Expr *expr_;

  LetIn1(const LetIn1 &);
  LetIn1 &operator=(const LetIn1 &);
  LetIn1(Ident p1, Expr *p2);
  ~LetIn1();
  virtual void accept(Visitor *v);
  virtual LetIn1 *clone() const;
  void swap(LetIn1 &);
};

class LetInExpr : public LetIn
{
public:
  Expr *expr_;

  LetInExpr(const LetInExpr &);
  LetInExpr &operator=(const LetInExpr &);
  LetInExpr(Expr *p1);
  ~LetInExpr();
  virtual void accept(Visitor *v);
  virtual LetInExpr *clone() const;
  void swap(LetInExpr &);
};

class ExprIdent : public Expr
{
public:
  Ident ident_;

  ExprIdent(const ExprIdent &);
  ExprIdent &operator=(const ExprIdent &);
  ExprIdent(Ident p1);
  ~ExprIdent();
  virtual void accept(Visitor *v);
  virtual ExprIdent *clone() const;
  void swap(ExprIdent &);
};

class ExprInteger : public Expr
{
public:
  Integer integer_;

  ExprInteger(const ExprInteger &);
  ExprInteger &operator=(const ExprInteger &);
  ExprInteger(Integer p1);
  ~ExprInteger();
  virtual void accept(Visitor *v);
  virtual ExprInteger *clone() const;
  void swap(ExprInteger &);
};

class ExprDouble : public Expr
{
public:
  Double double_;

  ExprDouble(const ExprDouble &);
  ExprDouble &operator=(const ExprDouble &);
  ExprDouble(Double p1);
  ~ExprDouble();
  virtual void accept(Visitor *v);
  virtual ExprDouble *clone() const;
  void swap(ExprDouble &);
};

class ExprString : public Expr
{
public:
  String string_;

  ExprString(const ExprString &);
  ExprString &operator=(const ExprString &);
  ExprString(String p1);
  ~ExprString();
  virtual void accept(Visitor *v);
  virtual ExprString *clone() const;
  void swap(ExprString &);
};







#endif
