/* File generated by the BNF Converter (bnfc 2.9.3). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   ProgramFunction    ********************/
ProgramFunction::ProgramFunction(Function *p1)
{
  function_ = p1;

}

ProgramFunction::ProgramFunction(const ProgramFunction & other)
{
  function_ = other.function_->clone();

}

ProgramFunction &ProgramFunction::operator=(const ProgramFunction & other)
{
  ProgramFunction tmp(other);
  swap(tmp);
  return *this;
}

void ProgramFunction::swap(ProgramFunction & other)
{
  std::swap(function_, other.function_);

}

ProgramFunction::~ProgramFunction()
{
  delete(function_);

}

void ProgramFunction::accept(Visitor *v)
{
  v->visitProgramFunction(this);
}

ProgramFunction *ProgramFunction::clone() const
{
  return new ProgramFunction(*this);
}



/********************   Program1    ********************/
Program1::Program1(Function *p1, Program *p2)
{
  function_ = p1;
  program_ = p2;

}

Program1::Program1(const Program1 & other)
{
  function_ = other.function_->clone();
  program_ = other.program_->clone();

}

Program1 &Program1::operator=(const Program1 & other)
{
  Program1 tmp(other);
  swap(tmp);
  return *this;
}

void Program1::swap(Program1 & other)
{
  std::swap(function_, other.function_);
  std::swap(program_, other.program_);

}

Program1::~Program1()
{
  delete(function_);
  delete(program_);

}

void Program1::accept(Visitor *v)
{
  v->visitProgram1(this);
}

Program1 *Program1::clone() const
{
  return new Program1(*this);
}



/********************   Function1    ********************/
Function1::Function1(Ident p1, ArgList *p2, Ident p3, LetIns *p4)
{
  ident_1 = p1;
  arglist_ = p2;
  ident_2 = p3;
  letins_ = p4;

}

Function1::Function1(const Function1 & other)
{
  ident_1 = other.ident_1;
  arglist_ = other.arglist_->clone();
  ident_2 = other.ident_2;
  letins_ = other.letins_->clone();

}

Function1 &Function1::operator=(const Function1 & other)
{
  Function1 tmp(other);
  swap(tmp);
  return *this;
}

void Function1::swap(Function1 & other)
{
  std::swap(ident_1, other.ident_1);
  std::swap(arglist_, other.arglist_);
  std::swap(ident_2, other.ident_2);
  std::swap(letins_, other.letins_);

}

Function1::~Function1()
{
  delete(arglist_);
  delete(letins_);

}

void Function1::accept(Visitor *v)
{
  v->visitFunction1(this);
}

Function1 *Function1::clone() const
{
  return new Function1(*this);
}



/********************   ArgListIdent    ********************/
ArgListIdent::ArgListIdent(Ident p1)
{
  ident_ = p1;

}

ArgListIdent::ArgListIdent(const ArgListIdent & other)
{
  ident_ = other.ident_;

}

ArgListIdent &ArgListIdent::operator=(const ArgListIdent & other)
{
  ArgListIdent tmp(other);
  swap(tmp);
  return *this;
}

void ArgListIdent::swap(ArgListIdent & other)
{
  std::swap(ident_, other.ident_);

}

ArgListIdent::~ArgListIdent()
{

}

void ArgListIdent::accept(Visitor *v)
{
  v->visitArgListIdent(this);
}

ArgListIdent *ArgListIdent::clone() const
{
  return new ArgListIdent(*this);
}



/********************   ArgList1    ********************/
ArgList1::ArgList1(Ident p1, ArgList *p2)
{
  ident_ = p1;
  arglist_ = p2;

}

ArgList1::ArgList1(const ArgList1 & other)
{
  ident_ = other.ident_;
  arglist_ = other.arglist_->clone();

}

ArgList1 &ArgList1::operator=(const ArgList1 & other)
{
  ArgList1 tmp(other);
  swap(tmp);
  return *this;
}

void ArgList1::swap(ArgList1 & other)
{
  std::swap(ident_, other.ident_);
  std::swap(arglist_, other.arglist_);

}

ArgList1::~ArgList1()
{
  delete(arglist_);

}

void ArgList1::accept(Visitor *v)
{
  v->visitArgList1(this);
}

ArgList1 *ArgList1::clone() const
{
  return new ArgList1(*this);
}



/********************   LetIns1    ********************/
LetIns1::LetIns1(LetIn *p1, OptionalHash *p2)
{
  letin_ = p1;
  optionalhash_ = p2;

}

LetIns1::LetIns1(const LetIns1 & other)
{
  letin_ = other.letin_->clone();
  optionalhash_ = other.optionalhash_->clone();

}

LetIns1 &LetIns1::operator=(const LetIns1 & other)
{
  LetIns1 tmp(other);
  swap(tmp);
  return *this;
}

void LetIns1::swap(LetIns1 & other)
{
  std::swap(letin_, other.letin_);
  std::swap(optionalhash_, other.optionalhash_);

}

LetIns1::~LetIns1()
{
  delete(letin_);
  delete(optionalhash_);

}

void LetIns1::accept(Visitor *v)
{
  v->visitLetIns1(this);
}

LetIns1 *LetIns1::clone() const
{
  return new LetIns1(*this);
}



/********************   LetIns2    ********************/
LetIns2::LetIns2(LetIn *p1, OptionalHash *p2, LetIns *p3)
{
  letin_ = p1;
  optionalhash_ = p2;
  letins_ = p3;

}

LetIns2::LetIns2(const LetIns2 & other)
{
  letin_ = other.letin_->clone();
  optionalhash_ = other.optionalhash_->clone();
  letins_ = other.letins_->clone();

}

LetIns2 &LetIns2::operator=(const LetIns2 & other)
{
  LetIns2 tmp(other);
  swap(tmp);
  return *this;
}

void LetIns2::swap(LetIns2 & other)
{
  std::swap(letin_, other.letin_);
  std::swap(optionalhash_, other.optionalhash_);
  std::swap(letins_, other.letins_);

}

LetIns2::~LetIns2()
{
  delete(letin_);
  delete(optionalhash_);
  delete(letins_);

}

void LetIns2::accept(Visitor *v)
{
  v->visitLetIns2(this);
}

LetIns2 *LetIns2::clone() const
{
  return new LetIns2(*this);
}



/********************   OptionalHash1    ********************/
OptionalHash1::OptionalHash1()
{

}

OptionalHash1::OptionalHash1(const OptionalHash1 & other)
{

}

OptionalHash1 &OptionalHash1::operator=(const OptionalHash1 & other)
{
  OptionalHash1 tmp(other);
  swap(tmp);
  return *this;
}

void OptionalHash1::swap(OptionalHash1 & other)
{

}

OptionalHash1::~OptionalHash1()
{

}

void OptionalHash1::accept(Visitor *v)
{
  v->visitOptionalHash1(this);
}

OptionalHash1 *OptionalHash1::clone() const
{
  return new OptionalHash1(*this);
}



/********************   OptionalHash2    ********************/
OptionalHash2::OptionalHash2()
{

}

OptionalHash2::OptionalHash2(const OptionalHash2 & other)
{

}

OptionalHash2 &OptionalHash2::operator=(const OptionalHash2 & other)
{
  OptionalHash2 tmp(other);
  swap(tmp);
  return *this;
}

void OptionalHash2::swap(OptionalHash2 & other)
{

}

OptionalHash2::~OptionalHash2()
{

}

void OptionalHash2::accept(Visitor *v)
{
  v->visitOptionalHash2(this);
}

OptionalHash2 *OptionalHash2::clone() const
{
  return new OptionalHash2(*this);
}



/********************   LetIn1    ********************/
LetIn1::LetIn1(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

LetIn1::LetIn1(const LetIn1 & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

LetIn1 &LetIn1::operator=(const LetIn1 & other)
{
  LetIn1 tmp(other);
  swap(tmp);
  return *this;
}

void LetIn1::swap(LetIn1 & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

LetIn1::~LetIn1()
{
  delete(expr_);

}

void LetIn1::accept(Visitor *v)
{
  v->visitLetIn1(this);
}

LetIn1 *LetIn1::clone() const
{
  return new LetIn1(*this);
}



/********************   LetInExpr    ********************/
LetInExpr::LetInExpr(Expr *p1)
{
  expr_ = p1;

}

LetInExpr::LetInExpr(const LetInExpr & other)
{
  expr_ = other.expr_->clone();

}

LetInExpr &LetInExpr::operator=(const LetInExpr & other)
{
  LetInExpr tmp(other);
  swap(tmp);
  return *this;
}

void LetInExpr::swap(LetInExpr & other)
{
  std::swap(expr_, other.expr_);

}

LetInExpr::~LetInExpr()
{
  delete(expr_);

}

void LetInExpr::accept(Visitor *v)
{
  v->visitLetInExpr(this);
}

LetInExpr *LetInExpr::clone() const
{
  return new LetInExpr(*this);
}



/********************   ExprIdent    ********************/
ExprIdent::ExprIdent(Ident p1)
{
  ident_ = p1;

}

ExprIdent::ExprIdent(const ExprIdent & other)
{
  ident_ = other.ident_;

}

ExprIdent &ExprIdent::operator=(const ExprIdent & other)
{
  ExprIdent tmp(other);
  swap(tmp);
  return *this;
}

void ExprIdent::swap(ExprIdent & other)
{
  std::swap(ident_, other.ident_);

}

ExprIdent::~ExprIdent()
{

}

void ExprIdent::accept(Visitor *v)
{
  v->visitExprIdent(this);
}

ExprIdent *ExprIdent::clone() const
{
  return new ExprIdent(*this);
}



/********************   ExprInteger    ********************/
ExprInteger::ExprInteger(Integer p1)
{
  integer_ = p1;

}

ExprInteger::ExprInteger(const ExprInteger & other)
{
  integer_ = other.integer_;

}

ExprInteger &ExprInteger::operator=(const ExprInteger & other)
{
  ExprInteger tmp(other);
  swap(tmp);
  return *this;
}

void ExprInteger::swap(ExprInteger & other)
{
  std::swap(integer_, other.integer_);

}

ExprInteger::~ExprInteger()
{

}

void ExprInteger::accept(Visitor *v)
{
  v->visitExprInteger(this);
}

ExprInteger *ExprInteger::clone() const
{
  return new ExprInteger(*this);
}



/********************   ExprDouble    ********************/
ExprDouble::ExprDouble(Double p1)
{
  double_ = p1;

}

ExprDouble::ExprDouble(const ExprDouble & other)
{
  double_ = other.double_;

}

ExprDouble &ExprDouble::operator=(const ExprDouble & other)
{
  ExprDouble tmp(other);
  swap(tmp);
  return *this;
}

void ExprDouble::swap(ExprDouble & other)
{
  std::swap(double_, other.double_);

}

ExprDouble::~ExprDouble()
{

}

void ExprDouble::accept(Visitor *v)
{
  v->visitExprDouble(this);
}

ExprDouble *ExprDouble::clone() const
{
  return new ExprDouble(*this);
}



/********************   ExprString    ********************/
ExprString::ExprString(String p1)
{
  string_ = p1;

}

ExprString::ExprString(const ExprString & other)
{
  string_ = other.string_;

}

ExprString &ExprString::operator=(const ExprString & other)
{
  ExprString tmp(other);
  swap(tmp);
  return *this;
}

void ExprString::swap(ExprString & other)
{
  std::swap(string_, other.string_);

}

ExprString::~ExprString()
{

}

void ExprString::accept(Visitor *v)
{
  v->visitExprString(this);
}

ExprString *ExprString::clone() const
{
  return new ExprString(*this);
}







